## Q.1 What is Event Loop?

**Answer:**
* The Event Loop is the core mechanism that lets Node.js handle asynchronous, non-blocking operations on a single thread.
* It works with libuv to offload I/O tasks (like file reads, HTTP requests) to the system or thread pool.

* Once tasks are complete, the event loop queues their callbacks and executes them one by one.

* **It has phases like:**

    *  Timers (setTimeout, setInterval) 

    *  Poll (I/O callbacks)

    * Check (setImmediate)

    * Microtasks (Promise.then, async/await)

* Microtasks run before the next phase of the loop.


## Q.2 What is Callback queue?

**Answer:**
The Callback Queue (also called the Task Queue) is where ready-to-run asynchronous callbacks wait to be executed by the Event Loop.

**How It Works:**
* You run some async code like setTimeout, fs.readFile, or an HTTP request.

<!-- * Node.js offloads the task using libuv(worker threads do the job in background). -->
* Node.js offloads certain asynchronous tasks to libuv, which may use a thread pool (worker threads in libuv, not JavaScript Worker Threads) to perform the work in the background.

* When the task finishes, its callback function is pushed to the Callback Queue.

* The Event Loop picks callbacks from the queue and executes them when the call stack is empty and after microtasks are done.

## Q.3 Execution of callbacks

```javascript
    console.log("Start");

    setTimeout(() => {
        console.log("From Callback Queue");
        }, 0);

    Promise.resolve().then(() => {
    console.log("From Microtask Queue");
    });

    console.log("End");
```
**Answer:**
```sql
    Start
    End
    From Microtask Queue
    From Callback Queue
```
* Even though setTimeout(..., 0) has 0ms delay, the microtask (Promise.then) runs first.
Promises have higher priority in event loop.



## Q.4 `process.nextTick()` in Node.js?

**Answer:**
`process.nextTick()` is a special function in Node.js that schedules a callback to be executed immediately after the current operation completes, before the event loop continues to the next phase.

* What It Does
    * Adds the callback to the "next tick queue", which is processed after the current function, but before any I/O or timers.

    * It has higher priority than Promises and other asynchronous tasks.

```javascript

    console.log("Start");

    process.nextTick(() => {
    console.log("process.nextTick");
    });

    Promise.resolve().then(() => {
    console.log("Promise.then");
    });

    setTimeout(() => {
    console.log("setTimeout");
    }, 0);

    console.log("End");

```

* **Output:**
```sql
    Start
    End
    process.nextTick
    Promise.then
    setTimeout
```


## Q.5 `setImmediate()` in Node.js?

**Answer:**
`setImmediate()` is a Node.js function that schedules a callback to be executed in the next iteration (tick) of the event loop, after I/O events are processed.
* **Execution Order Example:**
```javascript
const fs = require('fs');

fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log("setTimeout");
  }, 0);

  setImmediate(() => {
    console.log("setImmediate");
  });
});
```
* **Output:**
```arduino
setImmediate
setTimeout
```
* Inside I/O callbacks, setImmediate() usually runs before setTimeout() because of how the event loop phases work.


## Q.6 `setTimeout()` in Node.js?

**Answer:**
`setTimeout()` is a built-in function used to schedule code to run after a specified delay (in milliseconds). It places the callback in the Timers phase of the Node.js event loop.

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Inside setTimeout");
}, 1000); // runs after ~1 sec

console.log("End");

```
* Output:

```sql
Start
End
Inside setTimeout

```

## Q.7 Streams in Node.js?

**Answer:**
* Streams in Node.js are abstractions for working with data that is read or written sequentially over time, rather than loading it all at once.

* **They're especially useful for:**

    * Handling large files

    * Network communication

    * Efficient memory usage

* **Benefits of Streams:**
    * Efficient memory usage

    * Handles large files or data sources

    * Enables piping for clean code

    * Built into Node's core modules (like fs, http, net, zlib)

* **Example:**
```javascript
const fs = require('fs');

// Read from a file and write to another using streams
const readStream = fs.createReadStream('input.txt');
const writeStream = fs.createWriteStream('output.txt');

// Pipe the data from readStream to writeStream
readStream.pipe(writeStream);

console.log("File copied using stream");

```

## Q.8 Buffers in Node.js?

**Answer:**
Buffers in Node.js are used to handle binary data directly in memory â€” especially useful when dealing with file systems, streams, or network operations.

Unlike strings (which handle text), buffers are used to work with raw binary data â€” sequences of bytes.

* Why Buffers?

    JavaScript (by default) does not support binary data well. Node.js introduces the Buffer class to fill that gap, particularly for:

    - File I/O (fs.readFile, fs.createReadStream)

    - Networking (net, http)

    - Streaming binary data (images, PDFs, etc.)
* **Example:**
```javascript
const buf1 = Buffer.from("Hello");
console.log(buf1);           // <Buffer 48 65 6c 6c 6f>
console.log(buf1.toString()); // "Hello"
```

## Q.9 Clusters in Node.js?

**Answer:**
Clusters in Node.js enable you to scale your application by utilizing multiple CPU cores. Since Node.js runs in a single-threaded event loop, clusters allow you to run multiple instances of your app, each on its own thread (child process), and share the same port.

* **Example:**
```javascript
const cluster = require('cluster');
const http = require('http');
const os = require('os');

const numCPUs = os.cpus().length;

if (cluster.isMaster) {
  console.log(`ðŸ‘‘ Master process ${process.pid} is running`);

  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // If a worker dies, fork a new one
  cluster.on('exit', (worker, code, signal) => {
    console.log(`ðŸ’€ Worker ${worker.process.pid} died`);
    cluster.fork();
  });

} else {
  // Worker processes have a HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Hello from worker ${process.pid}\n`);
  }).listen(3000);

  console.log(`ðŸš§ Worker ${process.pid} started`);
}

```


## Q.10 Child Process

**Answer:**
Child Process in Node.js allows you to run external programs or scripts in separate processes, enabling parallel execution outside the main event loop.

Runs in isolated memory space.

The `child_process.spawn()`, `child_process.fork()`, `child_process.exec()`, and `child_process.execFile()` are the methods methods which support the creation of sub-processes asynchronously.
* `exec()` â†’ good for small outputs, returns a buffer
* `spawn()` â†’ good for large/streamed output
* `fork()` â†’ best for Node.js scripts and message passing
```javascript
const { fork } = require('child_process');
const child = fork('worker.js');
child.send({ task: 'processData' });

```


## Q.11 Worker threads

**Answer:**
Worker Threads allow you to run JavaScript code in parallel threads (within the same process) â€” ideal for CPU-bound tasks that would otherwise block the event loop.

Runs in shared memory space.(via `SharedArrayBuffer`)

Used for mathematical operations or cryptography in Node.js


## Q.12 Callback hell (Pyramid of doom)

**Answer:**
Callback hell, also known as the "Pyramid of Doom," refers to a situation in programming where multiple nested callbacks make the code hard to read, understand, and maintain. This often occurs when dealing with asynchronous operations, like making API calls or handling file I/O, where one operation depends on the completion of another. 

The asynchronous function requires callbacks as a return parameter. When multiple asynchronous functions are chained together then callback hell situation comes up. 

```javascript
```
## Q.13 What are Event Listeners ? 

**Answer:**
**Event Listeners** are similar to call back functions but are associated with some event. For example when a server listens to http request on a given port a event will be generated and to specify http server has received and will invoke corresponding event listener. Basically, Event listener's are also call backs for a corresponding event.

Node.js has built in event's and built in event listeners. Node.js also provides functionality to create Custom events and Custom Event listeners.

## Q.14 What is Event Emmitter ?

**Answer:**
All objects that emit events are members of EventEmitter class. These objects expose an `eventEmitter.on()` function that allows one or more functions to be attached to named events emitted by the object.

When the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. 

```js
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
myEmitter.emit('event');
```

## Q.15 What is REPL in context of Node?

**Answer:**
**REPL** stands for Read Eval Print Loop and it represents a computer environment like a window console or unix/linux shell where a command is entered and system responds with an output. Node.js or Node comes bundled with a REPL environment. It performs the following desired tasks.

*   **Read** \- Reads user's input, parse the input into JavaScript data-structure and stores in memory.
*   **Eval** \- Takes and evaluates the data structure
*   **Print** \- Prints the result
*   **Loop** \- Loops the above command until user press ctrl-c twice.


## Q.16 How to secure node.js application ?

**Answer:** 

## Q.17 How to debug node.js application ?

**Answer:**

## Q.18 How to handle to many requests ?

**Answer:**

## Q.19 Security practices to follow in Node application

**Answer:**


## Q.20 What to do before closing Node server ?

**Answer:**


## Q.21 DDOS Attacks and prevention

**Answer:**


## Q.22 Redis

**Answer:**

## Q.23 Microservice Communication

**Answer:**

## Q.24 `fork()` vs `spawn()`

**Answer:**

## Q.25 `res.json()` vs `res.send()` vs `res.end()`

**Answer:**

## Q.26 Memory leaks and prevention

**Answer:**

## Q.27 Dynamic module importing

**Answer:**

## Q.28 Event reactor pattern in Node.js

**Answer:**

## Q.29 HTTP vs TCP

**Answer:**

## Q.30 Webhook

**Answer:**

## Q.31 Helmet vs Multer

**Answer:**


## Q.32 Debugging in Node application

**Answer:**

## Q.33 Reverse proxy and its use in Node App

**Answer:**

## Q.34 Scaffolding in Node

**Answer:**

## Q.35 3-Tier Architecture 

**Answer:**

## Q.36 Authentication and its types

**Answer:**

## Q.37 Exception and Error handling

**Answer:**
Node.js provides several global-level error handlers that can catch unhandled errors or rejections anywhere in your app.

* **process.on('uncaughtException')**
  Catches synchronous errors and async errors thrown outside Promises
  that are not caught anywhere in the code.

  ```js
    process.on('uncaughtException', (err) => {
      console.error('ðŸ”¥ Uncaught Exception:', err.message);
      // Optionally cleanup or restart process
      process.exit(1); // Important: exit after handling
    });

    setTimeout(() => {
      throw new Error('Something broke!');
    }, 1000);
  ```
  * Once this fires, the process is in an unstable state â€” you should exit gracefully.
  * Donâ€™t use it to â€œcontinueâ€ the app, use it for logging and cleanup.

* **process.on('unhandledRejection')**
  Catches unhandled Promise rejections â€”
  for example, if you forget to .catch() on a Promise.

  ```js
    process.on('unhandledRejection', (reason, promise) => {
      console.error('âš ï¸ Unhandled Rejection:', reason);
      // Optional cleanup
    });

    Promise.reject(new Error("Promise failed"));
  ```

  * In modern Node versions, unhandled rejections can even terminate the process, so handle them globally.

| Mechanism                          | Handles                       | Example                              |
| ---------------------------------- | ----------------------------- | ------------------------------------ |
| `try...catch`                      | Synchronous errors            | `try { throw err } catch {}`         |
| `process.on('uncaughtException')`  | Uncaught sync & async errors  | `setTimeout(()=>{ throw err })`      |
| `process.on('unhandledRejection')` | Uncaught Promise rejections   | `Promise.reject(err)`                |
| `process.on('exit')`               | Before shutdown               | Cleanup operations                   |
| Express middleware                 | Request/response cycle errors | `app.use((err, req, res, next)=>{})` |


## Q.38 `axios()`

**Answer:**

## Q.39 Status codes

**Answer:**

| Code                          | Meaning                                            | Description                          |
| -----------------------       | -------------------------------------------        | ------------------------------------ |
| **200 OK**                    | Success                                            | Most common success code             |
| **201 Created**               | Resource created                                   | Used after POST/PUT (e.g., new user) |
| **202 Accepted**              | Request accepted, being processed async            |                                      |
| **204 No Content**            | Success but no response body (e.g., DELETE)        |                                      |
| **206 Partial Content**       | Partial response (e.g., for range requests)        |                                      |
| **400 Bad Request**           | Invalid syntax or parameters                       |                                      |
| **401 Unauthorized**          | Authentication required (invalid or missing token) |                                      |
| **403 Forbidden**             | Authenticated but no permission                    |                                      |
| **404 Not Found**             | Resource not found                                 |                                      |
| **405 Method Not Allowed**    | Wrong HTTP method (e.g., POST instead of GET)      |                                      |
| **409 Conflict**              | Resource conflict (e.g., duplicate record)         |                                      |
| **422 Unprocessable Entity**  | Validation failed                                  |                                      |
| **429 Too Many Requests**     | Rate limit exceeded                                |                                      |
| **500 Internal Server Error** | Generic server error                               |                                      |
| **501 Not Implemented**       | Feature not supported                              |                                      |
| **502 Bad Gateway**           | Invalid response from upstream server              |                                      |
| **503 Service Unavailable**   | Server down or overloaded                          |                                      |
| **504 Gateway Timeout**       | Upstream server didnâ€™t respond in time             |                                      |


## Q.40 Stateful vs Stateless 

**Answer:**

## Q.41 'Bearer' - token

**Answer:**

## Q.42 Access Token vs Refresh token

**Answer:**

## Q.43 JWT - JSON Web Token

**Answer:**

## Q.44 Localisation of Node App

**Answer:**

## Q.45 Globals provided by Node

**Answer:**
In Node.js, certain objects are available in all modules without requiring an import â€” they are part of the global scope.

Unlike browsers, Node.js doesnâ€™t have `window` â€” it has a global object called `global`.

| **Name**           | **Type** | **Description**                                                | **Example**                                       |
| ------------------ | -------- | -------------------------------------------------------------- | ------------------------------------------------- |
| `__dirname`        | String   | Directory name of the current module                           | `console.log(__dirname);`                         |
| `__filename`       | String   | Full path of the current module file                           | `console.log(__filename);`                        |
| `exports`          | Object   | Used to export functions or objects from a module              | `exports.myFunc = () => {};`                      |
| `module`           | Object   | Represents the current module (contains `exports`, `id`, etc.) | `console.log(module.exports);`                    |
| `require()`        | Function | Used to import modules                                         | `const fs = require('fs');`                       |
| `process`          | Object   | Provides info & control over the Node.js process               | `process.exit();`                                 |
| `Buffer`           | Class    | Used to handle binary data                                     | `const buf = Buffer.from('hello');`               |
| `setTimeout()`     | Function | Execute code after a delay                                     | `setTimeout(fn, 1000);`                           |
| `setInterval()`    | Function | Execute code repeatedly at intervals                           | `setInterval(fn, 1000);`                          |
| `setImmediate()`   | Function | Execute code after I/O events                                  | `setImmediate(fn);`                               |
| `clearTimeout()`   | Function | Cancel a timeout                                               | `clearTimeout(timer);`                            |
| `clearInterval()`  | Function | Cancel an interval                                             | `clearInterval(timer);`                           |
| `clearImmediate()` | Function | Cancel an immediate                                            | `clearImmediate(timer);`                          |
| `console`          | Object   | Logging utility (global)                                       | `console.log('Hello');`                           |
| `queueMicrotask()` | Function | Schedule a microtask to run after current event loop           | `queueMicrotask(() => console.log("microtask"));` |




## Q.46 `async.parallel()` vs `async.series()` vs `async.queue()`

**Answer:**
The async library provides utilities to manage asynchronous operations â€” especially when you have multiple async tasks (like API calls, file reads, DB queries, etc.).

Two common patterns are:

| Method           | Execution Order                 | When Next Task Runs            | Use Case                   |
| ---------------- | ------------------------------- | ------------------------------ | -------------------------- |
| `async.parallel` | All tasks start **together**    | Doesnâ€™t wait for others        | Independent tasks          |
| `async.series`   | Tasks run **one after another** | Waits for previous to complete | Dependent or ordered tasks |


* **Example: `async.parallel()`**

  ```js
  const async = require('async');
  async.parallel(
   {
      task1: function (callback) {
        setTimeout(() => {
          console.log('Task 1 done');
          callback(null, 'Result 1');
        }, 2000);
      },
      task2: function (callback) {
        setTimeout(() => {
          console.log('Task 2 done');
          callback(null, 'Result 2');
        }, 1000);
      }
    },
    function (err, results) {
      if (err) return console.error(err);
      console.log('All done:', results);
    }
  );

  ```

* **Example: `async.series()`**
  ```js
    const async = require('async');

    async.series(
      {
        task1: function (callback) {
          setTimeout(() => {
            console.log('Task 1 done');
            callback(null, 'Result 1');
          }, 2000);
        },
        task2: function (callback) {
          setTimeout(() => {
            console.log('Task 2 done');
            callback(null, 'Result 2');
          }, 1000);
        }
      },
      function (err, results) {
        if (err) return console.error(err);
        console.log('All done:', results);
      }
    );
  ```

## Q.47 HTTP Methods

**Answer:**

| **Method**  | **Meaning / Use**                   | **Request Body?** | **Idempotent?** | **Safe?** | **Typical Use Case**                       |
| ----------- | ----------------------------------- | ----------------- | --------------- | --------- | ------------------------------------------ |
| **GET**     | Retrieve data from the server       | âŒ No              | âœ… Yes           | âœ… Yes     | Fetch data (e.g., `/users`, `/products/1`) |
| **POST**    | Create new resource                 | âœ… Yes             | âŒ No            | âŒ No      | Add new item (e.g., `/users`)              |
| **PUT**     | Replace (update) an entire resource | âœ… Yes             | âœ… Yes           | âŒ No      | Replace object (e.g., update user info)    |
| **PATCH**   | Update part of a resource           | âœ… Yes             | âœ… Yes           | âŒ No      | Modify only some fields                    |
| **DELETE**  | Remove resource                     | âŒ Usually No      | âœ… Yes           | âŒ No      | Delete user or item                        |
| **HEAD**    | Like GET, but only returns headers  | âŒ No              | âœ… Yes           | âœ… Yes     | Check resource existence                   |
| **OPTIONS** | Ask what methods are allowed        | âŒ No              | âœ… Yes           | âœ… Yes     | Used in CORS preflight requests            |


## Q.48 Promise chaining

**Answer:**

## Q.49 exit code

**Answer:**

## Q.47 PM2 (Process Manager 2)

**Answer:**

## Q.48 Import vs require

**Answer:**

## Q.49 Logging in Node app (winston).

**Answer:**

## Q.50 Scenario: for example You have a binary on server, you have to run that binary on server and get the output from binary and use it into your node process. How to achieve this?

**Answer:**


## Q.51 Clickjacking

**Answer:**

## Q.52 Kafka and its uses in node app.

**Answer:**

## Q.53 Rate Limiting

**Answer:**
Rate limiting means controlling how many requests a user (or IP) can make to your API within a specific time window.

* **Example:** 
  Allow each user to make only 100 requests per 15 minutes.
  After that, return HTTP `429 Too Many Requests`.

* **Why Rate Limiting?**
  * Prevents abuse / DDoS attacks
  * Protects backend performance
  * Stops brute-force login attempts

* **Use cases** 
  | Approach                                | Description                                        |
  | --------------------------------------- | -------------------------------------------------- |
  | **In-memory (e.g. Express middleware)** | Good for single server apps                        |
  | **Redis-based**                         | Distributed rate limiting (for multiple servers)   |
  | **API Gateway based**                   | Offloaded to tools like Nginx, Kong, or Cloudflare |

* **Implementation**

  1. **Using Express Middleware (Simple Example):**

    ```bash
      npm install express-rate-limit
    ```
    ```js
      import express from "express";
      import rateLimit from "express-rate-limit";

      const app = express();

      const limiter = rateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100,                 // Limit each IP to 100 requests per windowMs
        message: "Too many requests from this IP, please try again later",
      });

      app.use(limiter);

      app.get("/", (req, res) => {
        res.send("Hello Adarsh ðŸ‘‹");
      });

      app.listen(3000, () => console.log("Server running on port 3000"));
    ```
    * Works well for single-instance apps
    * Does not share limits across multiple servers

  2. **Using Redis (For distributed rate limiting)**
    Use this when your app runs on multiple servers or containers (like in production or Kubernetes).

    ```bash
      npm install redis express-rate-limit rate-limit-redis
    ```
    ```js
      import express from "express";
      import rateLimit from "express-rate-limit";
      import RedisStore from "rate-limit-redis";
      import { createClient } from "redis";

      const redisClient = createClient({ url: "redis://localhost:6379" });
      await redisClient.connect();

      const app = express();

      const limiter = rateLimit({
        store: new RedisStore({
          sendCommand: (...args) => redisClient.sendCommand(args),
        }),
        windowMs: 60 * 1000, // 1 minute
        max: 10, // 10 requests per minute per user
        message: "Too many requests. Try again in a minute.",
      });

      app.use(limiter);

      app.get("/", (req, res) => {
        res.send("Rate limit test successful âœ…");
      });

      app.listen(3000, () => console.log("Server running on port 3000"));
    ```
    * Works across multiple instances
    * Persistent limit tracking
    * Fast since Redis is in-memory
