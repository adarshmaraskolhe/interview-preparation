## Q.1 What is Event Loop?

**Answer:**
* The Event Loop is the core mechanism that lets Node.js handle asynchronous, non-blocking operations on a single thread.
* It works with libuv to offload I/O tasks (like file reads, HTTP requests) to the system or thread pool.

* Once tasks are complete, the event loop queues their callbacks and executes them one by one.

* **It has phases like:**

    *  Timers (setTimeout, setInterval) 

    *  Poll (I/O callbacks)

    * Check (setImmediate)

    * Microtasks (Promise.then, async/await)

* Microtasks run before the next phase of the loop.


## Q.2 What is Callback queue?

**Answer:**
The Callback Queue (also called the Task Queue) is where ready-to-run asynchronous callbacks wait to be executed by the Event Loop.

**How It Works:**
* You run some async code like setTimeout, fs.readFile, or an HTTP request.

<!-- * Node.js offloads the task using libuv(worker threads do the job in background). -->
* Node.js offloads certain asynchronous tasks to libuv, which may use a thread pool (worker threads in libuv, not JavaScript Worker Threads) to perform the work in the background.

* When the task finishes, its callback function is pushed to the Callback Queue.

* The Event Loop picks callbacks from the queue and executes them when the call stack is empty and after microtasks are done.

## Q.3 Execution of callbacks

```javascript
    console.log("Start");

    setTimeout(() => {
        console.log("From Callback Queue");
        }, 0);

    Promise.resolve().then(() => {
    console.log("From Microtask Queue");
    });

    console.log("End");
```
**Answer:**
```sql
    Start
    End
    From Microtask Queue
    From Callback Queue
```
* Even though setTimeout(..., 0) has 0ms delay, the microtask (Promise.then) runs first.
Promises have higher priority in event loop.



## Q.4 `process.nextTick()` in Node.js?

**Answer:**
`process.nextTick()` is a special function in Node.js that schedules a callback to be executed immediately after the current operation completes, before the event loop continues to the next phase.

* What It Does
    * Adds the callback to the "next tick queue", which is processed after the current function, but before any I/O or timers.

    * It has higher priority than Promises and other asynchronous tasks.

```javascript

    console.log("Start");

    process.nextTick(() => {
    console.log("process.nextTick");
    });

    Promise.resolve().then(() => {
    console.log("Promise.then");
    });

    setTimeout(() => {
    console.log("setTimeout");
    }, 0);

    console.log("End");

```

* **Output:**

    Start
    End
    process.nextTick
    Promise.then
    setTimeout



