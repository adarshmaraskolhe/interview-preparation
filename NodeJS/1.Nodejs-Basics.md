# Node JS Interview Questions

## Q.1 What is node.js ?

**Answer:**  
Node.js is a runtime environment for javascript that allows you to run JavaScript code on the server side outside of a web browser.
*   **Built on Chrome’s V8 JavaScript engine:** - This gives Node.js high performance in executing JavaScript code.
*   **Non-blocking I/O and event-driven architecture:** - This makes it efficient and suitable for real-time applications like chat apps, online games, or live notifications.
*   **Used for backend development:** - While JavaScript is traditionally used on the client side (browser), Node.js lets you build the server side using JavaScript too.


## Q.2 Advantages of node.js

**Answer:**
*   **Fast Performance:** - Built on Chrome’s V8 engine, which compiles JavaScript to machine code.
Handles many operations (like file reads, network requests) asynchronously, making it highly efficient.
*   **Asynchronous & Non-Blocking I/O:** - Executes multiple tasks in parallel without waiting for one to finish.
Ideal for real-time applications (e.g., chats, live updates).
*   **Cross-Platform Development:** - Useful in building tools, desktop apps (with Electron), APIs, and even IoT solutions.


## Q.3 Is node.js single threaded ?

**Answer:**
Yes, Node.js is single-threaded 
* Node.js uses a single main thread to handle JavaScript execution.
* However, it uses non-blocking I/O and the event loop to efficiently manage multiple concurrent operations (like file access, network requests, etc.).

## Q.4 How node.js handles concurrency even after it is single threaded ?

**Answer:**
*   **Event Loop:** - The event loop is the core mechanism that enables Node.js to perform non-blocking operations. It continuously checks for tasks, executes them, and handles callbacks as asynchronous operations complete.
*   **Libuv & Thread Pool:** - Node.js uses a C++ library called libuv to handle asynchronous I/O operations. Although JavaScript runs on a single thread, libuv maintains a thread pool (usually 4 threads) that performs:

File system operations, DNS lookups, Compression, Crypto operations etc.

These tasks are passed to the thread pool and do not block the main thread.


## Q.5 Module in node.js

**Answer:** 
In Node.js, a module is a reusable piece of code that can be exported from one file and imported into another. Modules help keep your code organized, maintainable, and encapsulated.

*   **Core Modules:** - Built into Node.js – no need to install.
Examples: http, fs, path, os.

*   **Third-party Modules:** - Installed via npm (Node Package Manager).
Example: express, lodash, mongoose.

## Q.6 What is NPM?

**Answer:** 
NPM stands for Node Package Manager. It's the default package manager for Node.js and is used to install, manage, and share reusable JavaScript code (called packages or modules) in your project.

## Q.7 What is package.json?

**Answer:** 
package.json is a metadata file used in every Node.js project. It describes the project’s configuration, including its name, version, dependencies, scripts, and more. It's essential for managing packages with npm and for sharing your project with others.

## Q.8 What is package-lock.json?

**Answer:** 
The package-lock.json file is automatically generated by npm whenever you run npm install. It locks the exact versions of all installed packages—including nested dependencies—to ensure consistent installations across all environments.

## Q.9 Folder structure of node.js application?

**Answer:** 
```perl

my-app/
├── node_modules/         # Installed packages
├── public/               # Static assets (CSS, JS, images)
├── src/                  # Source code
│   ├── controllers/      # Route handler logic
│   ├── routes/           # API route definitions
│   ├── models/           # Database models (e.g., Mongoose, Sequelize)
│   ├── middlewares/      # Custom middleware functions
│   ├── services/         # Business logic layer (optional but recommended)
│   ├── utils/            # Utility/helper functions
│   ├── config/           # Configuration files (e.g., DB, env)
│   └── app.js            # Main Express app setup
├── .env                  # Environment variables
├── .gitignore            # Files/folders to ignore in Git
├── package.json          # Project metadata & dependencies
├── package-lock.json     # Dependency lock file
└── server.js             # Entry point to start the server

```

## Q.10 What is MVC?

**Answer:** 
MVC – Model View Controller
* Model: Database schemas (e.g., Mongoose models).

* View: If using a templating engine (e.g., EJS, Handlebars), it's rendered HTML.

* Controller: Handles routes, gets data from Model, returns it to View or as JSON.


## Q.11 Blocking vs Non blocking operations in node.js?

**Answer:** 
**Blocking:**
* Stops execution until task finishes
* Occupies the main thread
* Slower with I/O operations
* Eg.- `fs.readFileSync()`

**Non-Blocking:**
* Continues execution while the task completes in the background
* Frees the main thread to handle other tasks
* Faster and scalable under heavy I/O
* Eg.- `fs.readFile()` or `fs.promises.readFile()`

## Q.11 Synchronous vs Asynchronous?

**Answer:**

**Synchronous:**
* Code runs one line at a time, blocking the next line until finished
* Occupies the main thread
* Slower for I/O-heavy tasks
* Simple tasks, initial setups

**Asynchronous:**
* Code runs without waiting, using callbacks, promises, or async/await
* Frees main thread to handle more requests
* Faster and more scalable
* File I/O, HTTP requests, database calls

## Q.11 How Node.js Handles Asynchronous Code?

**Answer:**

**Single-threaded:** Node.js runs JavaScript on a single main thread but offloads I/O operations (like file reading) to background systems.
**libuv and the Thread Pool:** For I/O-intensive tasks (like file or network operations), Node.js uses libuv to offload work to background threads in a thread pool, so the main thread isn't blocked.
**Event Loop:** The event loop constantly checks for completed asynchronous tasks. Once a task finishes, its callback is added to a callback queue and executed when the main thread is available.
**Queues:**
* Callback Queue: Handles standard async operations like I/O and timers.
* Microtask Queue: Processes promise-based callbacks and functions like process.nextTick() before other callbacks.