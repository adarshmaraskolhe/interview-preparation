# Angular Interview Questions

## Q.1 What is Angular ?

**Answer:**  Angular is a powerful and popular open-source front-end framework primarily used for building single-page web applications (SPAs) and dynamic web applications. Developed and maintained by Google, it offers a comprehensive set of tools and libraries to streamline development, enabling developers to create robust, scalable, and maintainable applications. 

## Q.2 Why Typescript is used in Angular ?

**Answer:** Angular uses TypeScript, a superset of JavaScript, which adds static typing, improving code readability and maintainability. 

* **Static Typing :** TypeScript lets you define types (e.g., `string`, `number`, `boolean`, `custom interfaces`). This means:
    * You catch errors at compile time, not runtime.
    * It helps prevent bugs due to incorrect data usage.

* TypeScript supports **Object-Oriented Programming (OOP)** Features
    * Classes

    * Interfaces

    * Inheritance

    * Access modifiers (private, public, protected)

## Q.3 What is component in Angular ?

**Answer:**
A Component is the fundamental building block of the user interface. Every view you see in an Angular application is controlled by a component.

* A component in Angular is made up of:

    * Class – typescript class that contains logic and data

    * Template (HTML) – defines the UI

    * Styles (CSS) – defines the look and feel

    * Metadata (`@Component`decorator) – tells Angular how to use the component


## Q.4 Directives

**Answer:**
Directives are special instructions in the DOM (Document Object Model) that tell Angular to do something with an element or component. They are used to manipulate the structure or behavior of the DOM.


| Type           | Description                                            | Example                           |
| -------------- | ------------------------------------------------------ | --------------------------------- |
| **Component**  | A directive with a template (i.e., actual UI)          | `@Component`                      |
| **Structural** | Changes the structure of the DOM (add/remove elements) | `*ngIf`, `*ngFor`, `*ngSwitch`    |
| **Attribute**  | Changes the appearance or behavior of an element       | `ngClass`, `ngStyle`              |

* **Custom Directives:** We can create custom directives as well 
    * Eg. detect OnScroll event, prevent copy/paste, highlight element 

```ts
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'yellow';
  }
}

```

```html
<p appHighlight>This text is highlighted</p>
```

## Q.5 Decorators

**Answer:**
Decorators are special functions that attach metadata to classes, methods, properties, or parameters. Angular uses them extensively to define and configure things like components, services, modules, and dependency injection.

* Decorators is defined using `@` symbol.

* **Class Decorators:** Used to define metadata for classes
    * `@Component`, `@Directive`, `@Injectable`

* **Method Decorators:** Used to define metadata for methods
    * `@Hostlistener`, `@Hostbinding`

* **Property Decorators:** Used to define metadata for properties/variables
    * `@Input()`, `@Output()`


## Q.6 Services

**Answer:** A service is a class that contains business logic, reusable functions, or shared data. It is used to separate logic from components, making code modular, reusable, and testable.

* Keep components clean and focused only on the UI.

* Reuse logic like API calls, calculations, or state management.

* Share data between components.

* Encapsulate complex logic in a single place.

```ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'  // Makes this service available application-wide
})
export class DataService {
  getData() {
    return ['Angular', 'React', 'Vue'];
  }
}

```

## Q.7 Dependency Injection

**Answer:** Dependency Injection (DI) is a design pattern used in Angular to supply an object (a dependency) to another object instead of creating it manually.
```ts
@Injectable({
  providedIn: 'root'
})
export class LoggerService {
  log(msg: string) {
    console.log(msg);
  }
}
```
`@Injectable` marks class as a service which can be used using Dependency Injection.

* **Benefits of DI**
    * Loose coupling
    * Easier testing (mock dependencies)
    * Reusability of services
    * Centralized management of shared logic
    * Angular automatically handles lifecycle and scopes

* **Optional Dependency:**
An optional dependency is a service or object that may or may not be available for injection.
Instead of throwing an error when the dependency is missing, Angular will inject `null` if it's marked as optional.
```ts
import { Optional } from '@angular/core';

constructor(@Optional() private logger: LoggerService) {}

```
If LoggerService is not provided, Angular will inject null instead of throwing an error.

## Q.8 `<router-outlet>` in Angular

**Answer:**
The `<router-outlet>` is a built-in directive provided by Angular that acts as a placeholder where the matched component for the current route gets dynamically loaded.
* Angular supports **named outlets** for advanced routing, like modals or sidebars:

```html
<router-outlet></router-outlet> <!-- Primary outlet -->
<router-outlet name="sidebar"></router-outlet> <!-- Named outlet -->

```

## Q.9 Routing in Angular

**Answer:**
Routing in Angular allows the users to create a single-page application with multiple views and allows navigation between them. Users can switch between these views without losing the application state and properties.

## Q.10 Route parameters vs Query parameters in Angular

**Answer:**
* **Route parameters:**
  * Part of the URL path itself.

  * Defined with a colon (:) in the route config.

  * Used to identify resources, like an ID.

```ts

//=> /product/42

//routing module
{ path: 'product/:id', component: ProductComponent }

//Access in component

this.route.paramMap.subscribe(params => {
  const id = params.get('id');
});

```
* **Query Params:**
  * Appended to the URL after a ?

  * Used for optional filters, pagination, search, etc.

  * Doesn’t affect route matching.

```ts
//==> /products?category=books&page=2

//Component
this.route.queryParamMap.subscribe(params => {
  const category = params.get('category');
  const page = params.get('page');
});


```

## Q.11 `forRoot()` and `forChild()`

**Answer:**
`forRoot()` and `forChild()` are methods used for configuring modules, particularly within the Angular Router Module. `forRoot()` is used in the root module (typically AppModule) to create and provide the singleton Router service, while `forChild()` is used in feature modules to configure routes without creating a new Router instance. `forRoot()` is called only once in the application, while `forChild()` can be called multiple times in different feature modules. 

Key Differences:
* Scope: `forRoot()` is for the root module, and `forChild()` is for feature modules. 
* Router Instance: `forRoot()` creates the main Router instance for the application, while `forChild()` uses the existing Router instance from the root module. 
* Usage: `forRoot()` should be called only once in the root module, and `forChild()` can be called multiple times in feature modules. 



## Q.12 `loadChildren`

**Answer:** `loadChildren` is used to lazy load a feature module in Angular — meaning the module and its components are only loaded when the user navigates to that route. This improves initial load time of the application.

```ts
const routes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'admin',
    loadChildren: () =>
      import('./admin/admin.module').then(m => m.AdminModule) 
  }
];

```
admin module is lazily loaded using loadchildren.


## Q.13 Auth Guard

**Answer:**
Auth guards in Angular are a security feature that controls access to specific routes based on user authentication and authorization. They are implemented using the `CanActivate` interface, which determines whether a user can navigate to a particular route.

* **Auth guards are essential for:**
  * Protecting sensitive routes: Ensuring that only authenticated users can access certain parts of the application.
  * Implementing role-based access control: Allowing access based on user roles or permissions.
  * Redirecting unauthorized users: Preventing access to restricted content and guiding users to the appropriate pages.
In addition to CanActivate, Angular provides other route guards, such as CanActivateChild, CanDeactivate, and CanLoad, each serving different purposes in controlling navigation.

```ts
// app-routing.module.ts
const routes: Routes = [
  { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] },
  { path: 'login', component: LoginComponent },
];

```
```ts
// auth.guard.ts
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { AuthService } from './auth.service'; // custom service

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(private auth: AuthService, private router: Router) {}

  canActivate(): boolean {
    if (this.auth.isLoggedIn()) {
      return true;
    } else {
      this.router.navigate(['/login']); // redirect if not authenticated
      return false;
    }
  }
}

```

| Guard Type         | Purpose                                 |
| ------------------ | --------------------------------------- |
| `CanActivate`      | Check before entering a route           |
| `CanActivateChild` | Check before accessing child routes     |
| `CanLoad`          | Check before loading lazy modules       |
| `CanDeactivate`    | Check before navigating away from route |
| `Resolve`          | Fetch data before loading a route       |



## Q.14 `Resolve` Auth Guard

**Answer:** 
A route resolver is used to fetch data before a route loads.

It ensures that the component only loads after the data is ready.

Implemented using the `Resolve<T>` interface.

* **Example:**
1. **Create Auth Guard**
```ts
@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(private auth: AuthService, private router: Router) {}

  canActivate(): boolean {
    if (this.auth.isLoggedIn()) return true;

    this.router.navigate(['/login']);
    return false;
  }
}

```
2. **Create Resolver**
```ts
@Injectable({ providedIn: 'root' })
export class ProfileResolver implements Resolve<any> {
  constructor(private userService: UserService) {}

  resolve(): Observable<any> {
    return this.userService.getUserProfile(); // returns Observable<User>
  }
}
```

3. **Add to Routing Module**
```ts
const routes: Routes = [
  {
    path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard],
    resolve: {
      profile: ProfileResolver
    }
  },
  { path: 'login', component: LoginComponent }
];

```

## Q.15 

**Answer:** 