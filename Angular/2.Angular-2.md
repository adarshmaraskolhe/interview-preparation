## Q.1 Pipes

**Answer:**
Pipes in Angular are simple, powerful tools used to transform data directly in templates. They make template expressions cleaner, reusable, and more readable.

A Pipe takes in data, transforms it, and returns the modified result—similar to functions—but used inside HTML templates.
* ***Example:***

```html
        <span>{{ name | uppercase }}</span>
```
* **Uses**
    * Format data in templates
    * Avoid writing logic inside HTML
    * Reusable transformations
    * Improve readability

* **Built-in Pipes**
| Category       | Examples                                       |
| -------------- | ---------------------------------------------- |
| **Formatting** | `date`, `currency`, `percent`, `number`        |
| **String**     | `uppercase`, `lowercase`, `titlecase`, `slice` |
| **JSON**       | `json`                                         |
| **Custom**     | your own logic                                 |
| **Async**      | `async` pipe (handles Observables/Promises)    |

* 

## Q.2 Pure Pipe vs Inpure Pipe

**Answer:**

* **Pure Pipe**
    * Executes only when input changes
    * Performs better
    * Suitable for pure functions, immutable inputs

```ts
@Pipe({ name: 'multiply', pure: true })
export class MultiplyPipe implements PipeTransform {
  transform(value: number, factor: number) {
    return value * factor;
  }
}
```

* **Impure Pipes**
    * Executes on every change detection cycle
    * Used when data is mutable (arrays, objects)
    * Can impact performance
```ts
@Pipe({ name: 'filterList', pure: false })
export class FilterListPipe implements PipeTransform {
  transform(list: any[], search: string) {
    return list.filter(item => item.includes(search));
  }
}
```

## Q.3 Async Pipe 

**Answer:**
Handles Observables and Promises, auto-subscribes and auto-unsubscribes.

```ts
data$ = this.service.getData();
```

```html
<span> {{ data$ | async }}</span>
```


## Q.4 Angular Forms - Template vs Reactive

**Answer:**

* 1. **Template-driven Forms**
    * These forms are driven by the template (HTML).
    Most of the logic is in HTML using Angular directives.
    * **Best For:**
        * Simple forms
        * Small applications
        * Minimal logic
        * Two-way binding
```html
<form #myForm="ngForm" (ngSubmit)="submit(myForm)">
  <input name="username" ngModel required />
  <input name="email" ngModel email />
  <button type="submit">Submit</button>
</form>
```
```ts
submit(form: any) {
  console.log(form.value);
}
```

* 2. **Reactive Forms**
    * These forms are driven by TypeScript code.
    The form model is created and maintained in the component.
    * **Best For**
        * Complex, dynamic, large forms
        * Dynamic validation
        * High testability
        * Better performance
        * More control
```ts
form = new FormGroup({
  username: new FormControl('', Validators.required),
  email: new FormControl('', [Validators.required, Validators.email]),
});

submit() {
  console.log(this.form.value);
}
```
```html
<form [formGroup]="form" (ngSubmit)="submit()">
  <input formControlName="username" />
  <input formControlName="email" />
  <button>Submit</button>
</form>

```

* **Difference:**
| Feature           | Template-driven              | Reactive                       |
| ----------------- | ---------------------------- | ------------------------------ |
| **Form creation** | In HTML                      | In TypeScript                  |
| **Binding**       | Two-way `(ngModel)`          | One-way `[formControl]`        |
| **Data model**    | Generated by Angular         | Defined by developer           |
| **Validation**    | In template using attributes | In TS using Validators API     |
| **Form updates**  | Automatic                    | Explicit (setValue/patchValue) |
| **Unit testing**  | Hard                         | Very easy                      |
| **Scalability**   | Not good                     | Excellent                      |
| **Dynamic forms** | Hard                         | Very easy                      |
| **Performance**   | Lower                        | Higher (immutable)             |


## Q.4 Validation in forms - Template vs Reactive

**Answer:**

## Q.5 Change Detection

**Answer:**

## Q.6 @HostListener and @HostBinding

**Answer:**

## Q.7 View Encapsulation

**Answer:**

## Q.8 Performance Optimization of angular application

**Answer:**

## Q.9 AOT vs JIT

**Answer:**

## Q.10 TrackBy

**Answer:**

## Q.11 Template Reference Variable

**Answer:**

## Q.12 Promise

**Answer:**

## Q.13 Promise APIs

**Answer:**

## Q.14 Async Await

**Answer:**

## Q.15 Observables

**Answer:**

## Q.16 Methods to Handle multiple observables

**Answer:**

## Q.17 Hot and Cold Observables

**Answer:**

## Q.18 Subjects 

**Answer:**

## Q.19 Signals

**Answer:**

## Q.20 Standalone Component

**Answer:**

## Q.21 Singleton Service

**Answer:**

## Q.22 Interceptors

**Answer:**

## Q.23 Error Handling - Exception Handling

**Answer:**

## Q.24 Tree Shaking

**Answer:**

## Q.25 WebSockets

**Answer:**


## Q.26 Module Federation

**Answer:**

## Q.27 Change Detection

**Answer:**


## Q.28 NgModule

**Answer:**


## Q.29 Security Practices in Angular Application

**Answer:**

## Q.30 Communication and State Management in microfrontend

**Answer:**

## Q.31 @ViewChild , @ViewChildren

**Answer:**

## Q.32 @ContentChild

**Answer:**

## Q.33 Memory Leaks and Garbage Collection

**Answer:**

## Q.34 WebPack

**Answer:**


## Q.35 Session Storage vs Local Storage vs Cookies

**Answer:**

